
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>3. Scoping Â· Cpp Coding Style</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Polin Huang">
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-prism/prism.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-emphasize/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../chapter4/naming.html" />
    
    
    <link rel="prev" href="../chapter2/headerfiles.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Release History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../chapter1/introduction.html">
            
                <a href="../chapter1/introduction.html">
            
                    
                    1. Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../chapter2/headerfiles.html">
            
                <a href="../chapter2/headerfiles.html">
            
                    
                    2. Header Files
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="scoping.html">
            
                <a href="scoping.html">
            
                    
                    3. Scoping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../chapter4/naming.html">
            
                <a href="../chapter4/naming.html">
            
                    
                    4. Naming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../chapter5/functions.html">
            
                <a href="../chapter5/functions.html">
            
                    
                    5. Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../chapter6/classes.html">
            
                <a href="../chapter6/classes.html">
            
                    
                    6. Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../chapter7/comments.html">
            
                <a href="../chapter7/comments.html">
            
                    
                    7. Comments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../chapter8/formatting.html">
            
                <a href="../chapter8/formatting.html">
            
                    
                    8. Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../chapter9/features.html">
            
                <a href="../chapter9/features.html">
            
                    
                    9. Other C++ Features
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../references.html">
            
                <a href="../references.html">
            
                    
                    REFERENCES
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >3. Scoping</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="3-scoping">3. Scoping</h1>
<h2 id="31-namespaces">3.1 Namespaces</h2>
<p>With few exceptions, place code in a namespace. Namespaces should have unique names based on the project name, and possibly its path. Do not use using-directives (e.g., using namespace foo). Do not use inline namespaces.</p>
<ul>
<li><p>Definition:</p>
<p>  Namespaces subdivide the global scope into distinct, named scopes, and so are useful for preventing name collisions in the global scope.</p>
</li>
<li><p>Pros:</p>
<p>  Namespaces provide a method for preventing name conflicts in large programs while allowing most code to use reasonably short names.</p>
</li>
<li><p>Cons:</p>
<p>  Namespaces can be confusing, because they complicate the mechanics of figuring out what definition a name refers to.</p>
</li>
<li><p>Decision:</p>
<ul>
<li>Follow the rules on <a href="https://www.poro.cool/CppCodingStyle/docs/chapter4/naming.html" target="_blank">Namespace Names</a></li>
<li>Terminate namespaces with comments as shown in the given examples.</li>
<li>Namespaces wrap the entire source file after includes, definitions/declarations and forward declarations of classes from other namespaces.</li>
</ul>
</li>
</ul>
<pre class="language-"><code class="lang-cpp"><span class="token comment">// In the .h file</span>
<span class="token keyword">namespace</span> mynamespace 
<span class="token punctuation">{</span>

<span class="token comment">// All declarations are within the namespace scope.</span>
<span class="token comment">// Notice the lack of indentation.</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment">// namespace mynamespace</span>
</code></pre>
<pre class="language-"><code class="lang-cpp"><span class="token comment">// In the .cpp file</span>
<span class="token keyword">namespace</span> mynamespace 
<span class="token punctuation">{</span>

<span class="token comment">// Definition of functions is within scope of the namespace.</span>
<span class="token keyword">void</span> MyClass<span class="token operator">::</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token punctuation">}</span>  <span class="token comment">// namespace mynamespace</span>
</code></pre>
<p>More complex .cpp files might have additional details, like flags or using-declarations.</p>
<pre class="language-"><code class="lang-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;a.h&quot;</span></span>

<span class="token function">ABSL_FLAG</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">,</span> someflag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">&quot;dummy flag&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> mynamespace 
<span class="token punctuation">{</span>

<span class="token keyword">using</span> <span class="token operator">::</span>foo<span class="token operator">::</span>Bar<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>code <span class="token keyword">for</span> mynamespace<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// Code goes against the left margin.</span>

<span class="token punctuation">}</span>  <span class="token comment">// namespace mynamespace</span>
</code></pre>
<pre class="language-"><code>- Do not declare anything in namespace std, including forward declarations of standard library classes. Declaring entities in namespace std is undefined behavior, i.e., not portable. To declare entities from the standard library, include the appropriate header file.
- You may not use a using-directive to make all names from a namespace available.
</code></pre><pre class="language-"><code class="lang-cpp"><span class="token comment">// Forbidden -- This pollutes the namespace.</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> foo<span class="token punctuation">;</span>
</code></pre>
<pre class="language-"><code>- Do not use Namespace aliases at namespace scope in header files except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file.
</code></pre><pre class="language-"><code class="lang-cpp"><span class="token comment">// Shorten access to some commonly used names in .cpp files.</span>
<span class="token keyword">namespace</span> baz <span class="token operator">=</span> <span class="token operator">::</span>foo<span class="token operator">::</span>bar<span class="token operator">::</span>baz<span class="token punctuation">;</span>
</code></pre>
<pre class="language-"><code class="lang-cpp"><span class="token comment">// Shorten access to some commonly used names (in a .h file).</span>
<span class="token keyword">namespace</span> librarian 
<span class="token punctuation">{</span>

<span class="token keyword">namespace</span> impl 
<span class="token punctuation">{</span>   <span class="token comment">// Internal, not part of the API.</span>
    <span class="token keyword">namespace</span> sidetable <span class="token operator">=</span> <span class="token operator">::</span>pipeline_diagnostics<span class="token operator">::</span>sidetable<span class="token punctuation">;</span>
<span class="token punctuation">}</span>   <span class="token comment">// namespace impl</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">my_inline_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// namespace alias local to a function (or method).</span>
    <span class="token keyword">namespace</span> baz <span class="token operator">=</span> <span class="token operator">::</span>foo<span class="token operator">::</span>bar<span class="token operator">::</span>baz<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token punctuation">}</span>  <span class="token comment">// namespace librarian</span>
</code></pre>
<pre class="language-"><code>- Do not use inline namespaces.
</code></pre><h2 id="32-unnamed-namespaces-and-static-variables">3.2 Unnamed Namespaces and Static Variables</h2>
<p>When definitions in a .cpp file do not need to be referenced outside that file, place them in an unnamed namespace or declare them static. Do not use either of these constructs in .h files.</p>
<ul>
<li><p>Definition:</p>
<p>  All declarations can be given internal linkage by placing them in unnamed namespaces. Functions and variables can also be given internal linkage by declaring them static. This means that anything you&apos;re declaring can&apos;t be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.</p>
</li>
<li><p>Decision:</p>
<p>  Use of internal linkage in .cpp files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in .h files.</p>
<p>  Format unnamed namespaces like named namespaces. In the terminating comment, leave the namespace name empty:</p>
</li>
</ul>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">namespace</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>  <span class="token comment">// namespace</span>
</code></pre>
<h2 id="33-nonmember-static-member-and-global-functions">3.3 Nonmember, Static Member, and Global Functions</h2>
<p>Prefer placing nonmember functions in a namespace; use completely global functions rarely. Do not use a class simply to group static members. Static methods of a class should generally be closely related to instances of the class or the class&apos;s static data.</p>
<ul>
<li><p>Pros:</p>
<p>  Nonmember and static member functions can be useful in some situations. Putting nonmember functions in a namespace avoids polluting the global namespace.</p>
</li>
<li><p>Cons:</p>
<p>  Nonmember and static member functions may make more sense as members of a new class, especially if they access external resources or have significant dependencies.</p>
</li>
<li><p>Decision:</p>
<p>  Sometimes it is useful to define a function not bound to a class instance. Such a function can be either a static member or a nonmember function. Nonmember functions should not depend on external variables, and should nearly always exist in a namespace. Do not create classes only to group static members; this is no different than just giving the names a common prefix, and such grouping is usually unnecessary anyway.</p>
</li>
</ul>
<h2 id="34-local-variables">3.4 Local Variables</h2>
<p>Place a function&apos;s variables in the narrowest scope possible, and initialize variables in the declaration.</p>
<p>C++ allows you to declare variables anywhere in a function. We encourage you to declare them in as local a scope as possible, and as close to the first use as possible. This makes it easier for the reader to find the declaration and see what type the variable is and what it was initialized to. In particular, initialization should be used instead of declaration and assignment, e.g.,:</p>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Bad -- initialization separate from declaration.</span>

<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Good -- declaration has initialization.</span>
</code></pre>
<pre class="language-"><code class="lang-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Prefer initializing using brace initialization.</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// Good -- v starts initialized.</span>
</code></pre>
<p>Variables needed for if, while and for statements should normally be declared within those statements, so that such variables are confined to those scopes. E.g.:</p>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">&apos;/&apos;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> str <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<p>There is one caveat: if the variable is an object, its constructor is invoked every time it enters scope and is created, and its destructor is invoked every time it goes out of scope.</p>
<pre class="language-"><code class="lang-cpp"><span class="token comment">// Inefficient implementation:</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  Foo f<span class="token punctuation">;</span>  <span class="token comment">// My ctor and dtor get called 1000000 times each.</span>
  f<span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It may be more efficient to declare such a variable used in a loop outside that loop:</p>
<pre class="language-"><code class="lang-cpp">Foo f<span class="token punctuation">;</span>  <span class="token comment">// My ctor and dtor get called once each.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  f<span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="35-static-and-global-variables">3.5 Static and Global Variables</h2>
<p>Objects with static storage duration are forbidden unless they are trivially destructible. Informally this means that the destructor does not do anything, even taking member and base destructors into account. More formally it means that the type has no user-defined or virtual destructor and that all bases and non-static members are trivially destructible. Static function-local variables may use dynamic initialization. Use of dynamic initialization for static class member variables or variables at namespace scope is discouraged, but allowed in limited circumstances; see below for details.</p>
<p>As a rule of thumb: a global variable satisfies these requirements if its declaration, considered in isolation, could be constexpr.</p>
<ul>
<li><p>Definition:</p>
<p>  Every object has a storage duration, which correlates with its lifetime. Objects with static storage duration live from the point of their initialization until the end of the program. Such objects appear as variables at namespace scope (&quot;global variables&quot;), as static data members of classes, or as function-local variables that are declared with the static specifier. Function-local static variables are initialized when control first passes through their declaration; all other objects with static storage duration are initialized as part of program start-up. All objects with static storage duration are destroyed at program exit (which happens before unjoined threads are terminated).</p>
<p>  Initialization may be dynamic, which means that something non-trivial happens during initialization. (For example, consider a constructor that allocates memory, or a variable that is initialized with the current process ID.) The other kind of initialization is static initialization. The two aren&apos;t quite opposites, though: static initialization always happens to objects with static storage duration (initializing the object either to a given constant or to a representation consisting of all bytes set to zero), whereas dynamic initialization happens after that, if required.</p>
</li>
<li><p>Pros:</p>
<p>  Global and static variables are very useful for a large number of applications: named constants, auxiliary data structures internal to some translation unit, command-line flags, logging, registration mechanisms, background infrastructure, etc.</p>
</li>
<li><p>Cons:</p>
<p>  Global and static variables that use dynamic initialization or have non-trivial destructors create complexity that can easily lead to hard-to-find bugs. Dynamic initialization is not ordered across translation units, and neither is destruction (except that destruction happens in reverse order of initialization). When one initialization refers to another variable with static storage duration, it is possible that this causes an object to be accessed before its lifetime has begun (or after its lifetime has ended). Moreover, when a program starts threads that are not joined at exit, those threads may attempt to access objects after their lifetime has ended if their destructor has already run.</p>
</li>
<li><p>Decision:</p>
<ol>
<li><p>Decision on Destruction</p>
<p> When destructors are trivial, their execution is not subject to ordering at all (they are effectively not &quot;run&quot;); otherwise we are exposed to the risk of accessing objects after the end of their lifetime. Therefore, we only allow objects with static storage duration if they are trivially destructible. Fundamental types (like pointers and int) are trivially destructible, as are arrays of trivially destructible types. Note that variables marked with constexpr are trivially destructible.</p>
</li>
</ol>
</li>
</ul>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> kNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// allowed</span>

<span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> X kX<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// allowed</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> kMessages<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// allowed</span>
<span class="token punctuation">}</span>

<span class="token comment">// allowed: constexpr guarantees trivial destructor</span>
<span class="token keyword">constexpr</span> std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> kArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// bad: non-trivial destructor</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>string kFoo <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// bad for the same reason, even though kBar is a reference (the</span>
<span class="token comment">// rule also applies to lifetime-extended temporary objects)</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> kBar <span class="token operator">=</span> <span class="token function">StrCat</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// bad: non-trivial destructor</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> kData <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class="language-"><code>Note that references are not objects, and thus they are not subject to the constraints on destructibility. The constraint on dynamic initialization still applies, though. In particular, a function-local static reference of the form static T&amp; t = \*new T; is allowed.
</code></pre><ol>
<li><p>Decision on Initialization</p>
<p> Initialization is a more complex topic. This is because we must not only consider whether class constructors execute, but we must also consider the evaluation of the initializer:</p>
</li>
</ol>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// fine</span>
<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ? (depends on f)</span>
Foo x<span class="token punctuation">;</span>        <span class="token comment">// ? (depends on Foo::Foo)</span>
Bar y <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ? (depends on g and on Bar::Bar)</span>
</code></pre>
<p>All but the first statement expose us to indeterminate initialization ordering.</p>
<p>The concept we are looking for is called constant initialization in the formal language of the C++ standard. It means that the initializing expression is a constant expression, and if the object is initialized by a constructor call, then the constructor must be specified as constexpr, too:</p>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token keyword">constexpr</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment">// fine, 5 is a constant expression</span>
Foo <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// fine, 2 is a constant expression and the chosen constructor is constexpr</span>
Foo a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// fine</span>
</code></pre>
<p>Constant initialization is always allowed. Constant initialization of static storage duration variables should be marked with constexpr or where possible the ABSL_CONST_INIT attribute. Any non-local static storage duration variable that is not so marked should be presumed to have dynamic initialization, and reviewed very carefully.</p>
<p>By contrast, the following initializations are problematic:</p>
<pre class="language-"><code class="lang-cpp"><span class="token comment">// Some declarations used below.</span>
time_t <span class="token function">time</span><span class="token punctuation">(</span>time_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// not constexpr!</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// not constexpr!</span>
<span class="token keyword">struct</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Problematic initializations.</span>
time_t m <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// initializing expression not a constant expression</span>
Foo <span class="token function">y</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// ditto</span>
Bar b<span class="token punctuation">;</span>                     <span class="token comment">// chosen constructor Bar::Bar() not constexpr</span>
</code></pre>
<p>Dynamic initialization of nonlocal variables is discouraged, and in general it is forbidden. However, we do permit it if no aspect of the program depends on the sequencing of this initialization with respect to all other initializations. Under those restrictions, the ordering of the initialization does not make an observable difference. For example:</p>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// allowed, as long as no other static variable</span>
                   <span class="token comment">// uses p in its own initialization</span>
</code></pre>
<p>Dynamic initialization of static local variables is allowed (and common).</p>
<ul>
<li><p>Common Patterns</p>
<ul>
<li>Global strings: if you require a global or static string constant, consider using a simple character array, or a char pointer to the first element of a string literal. String literals have static storage duration already and are usually sufficient.</li>
<li>Maps, sets, and other dynamic containers: if you require a static, fixed collection, such as a set to search against or a lookup table, you cannot use the dynamic containers from the standard library as a static variable, since they have non-trivial destructors. Instead, consider a simple array of trivial types, e.g., an array of arrays of ints (for a &quot;map from int to int&quot;), or an array of pairs (e.g., pairs of int and const char*). For small collections, linear search is entirely sufficient (and efficient, due to memory locality); consider using the facilities from absl/algorithm/container.h for the standard operations. If necessary, keep the collection in sorted order and use a binary search algorithm. If you do really prefer a dynamic container from the standard library, consider using a function-local static pointer, as described below.</li>
<li>Smart pointers (unique_ptr, shared_ptr): smart pointers execute cleanup during destruction and are therefore forbidden. Consider whether your use case fits into one of the other patterns described in this section. One simple solution is to use a plain pointer to a dynamically allocated object and never delete it (see last item).</li>
<li>Static variables of custom types: if you require static, constant data of a type that you need to define yourself, give the type a trivial destructor and a constexpr constructor.</li>
<li>If all else fails, you can create an object dynamically and never delete it by using a function-local static pointer or reference (e.g., static const auto&amp; impl = *new T(args...);).</li>
</ul>
</li>
</ul>
<h2 id="36-threadlocal-variables">3.6 thread_local Variables</h2>
<p>The thread_local variables that aren&apos;t declared inside a function must be initialized with a true compile-time constant, and this must be enforced by using the ABSL_CONST_INIT attribute. Prefer thread_local over other ways of defining thread-local data.</p>
<ul>
<li><p>Definition:</p>
<p>  Starting with C++11, variables can be declared with the thread_local specifier:</p>
</li>
</ul>
<pre class="language-"><code class="lang-cpp"><span class="token keyword">thread_local</span> Foo foo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
</code></pre>
<p>Such a variable is actually a collection of objects, so that when different threads access it, they are actually accessing different objects. thread_local variables are much like static storage duration variables in many respects. For instance, they can be declared at namespace scope, inside functions, or as static class members, but not as ordinary class members.</p>
<p>thread_local variable instances are initialized much like static variables, except that they must be initialized separately for each thread, rather than once at program startup. This means that thread_local variables declared within a function are safe, but other thread_local variables are subject to the same initialization-order issues as static variables (and more besides).</p>
<p>thread_local variable instances are destroyed when their thread terminates, so they do not have the destruction-order issues of static variables.</p>
<ul>
<li><p>Pros:</p>
<ul>
<li>thread_local data is inherently safe from races (because only one thread can ordinarily access it), which makes thread_local useful for concurrent programming.</li>
<li>thread_local is the only standard-supported way of creating thread-local data.</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>Accessing a thread_local variable may trigger execution of an unpredictable and uncontrollable amount of other code.</li>
<li>thread_local variables are effectively global variables, and have all the drawbacks of global variables other than lack of thread-safety.</li>
<li>The memory consumed by a thread_local variable scales with the number of running threads (in the worst case), which can be quite large in a program.</li>
<li>An ordinary class member cannot be thread_local.</li>
<li>thread_local may not be as efficient as certain compiler intrinsics.</li>
</ul>
</li>
<li><p>Decision:</p>
<p>  thread_local variables inside a function have no safety concerns, so they can be used without restriction. Note that you can use a function-scope thread_local to simulate a class- or namespace-scope thread_local by defining a function or static method that exposes it:</p>
</li>
</ul>
<pre class="language-"><code class="lang-cpp">Foo<span class="token operator">&amp;</span> <span class="token function">MyThreadLocalFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">thread_local</span> Foo result <span class="token operator">=</span> <span class="token function">ComplicatedInitialization</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The thread_local variables at class or namespace scope must be initialized with a true compile-time constant (i.e., they must have no dynamic initialization). To enforce this, thread_local variables at class or namespace scope must be annotated with ABSL_CONST_INIT (or constexpr, but that should be rare):</p>
<pre class="language-"><code class="lang-cpp">ABSL_CONST_INIT <span class="token keyword">thread_local</span> Foo foo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
</code></pre>
<p>The thread_local should be preferred over other mechanisms for defining thread-local data.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../chapter2/headerfiles.html" class="navigation navigation-prev " aria-label="Previous page: 2. Header Files">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../chapter4/naming.html" class="navigation navigation-next " aria-label="Next page: 4. Naming">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"3. Scoping","level":"1.4","depth":1,"next":{"title":"4. Naming","level":"1.5","depth":1,"path":"docs/chapter4/naming.md","ref":"docs/chapter4/naming.md","articles":[]},"previous":{"title":"2. Header Files","level":"1.3","depth":1,"path":"docs/chapter2/headerfiles.md","ref":"docs/chapter2/headerfiles.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","-highlight","prism","prism-themes","splitter","emphasize","back-to-top-button","chapter-fold"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"chapter-fold":{},"prism":{},"emphasize":{},"splitter":{},"search-pro":{},"fontsettings":{"theme":"white","family":"sans","size":2},"back-to-top-button":{},"prism-themes":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Polin Huang","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Cpp Coding Style","language":"en","gitbook":"*"},"file":{"path":"docs/chapter3/scoping.md","mtime":"2020-07-07T15:49:32.829Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-07-16T00:57:20.507Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

